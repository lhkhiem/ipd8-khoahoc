import { Request, Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import sequelize from '../config/database';
import { logActivity } from './activityLogController';

const DEFAULTS: Record<string, any> = {
  general: {
    siteName: 'PressUp CMS',
    siteDescription: 'A powerful content management system',
    siteUrl: process.env.SITE_URL || process.env.WEBSITE_ORIGIN || 'https://example.com',
    adminEmail: 'admin@pressup.com',
    businessInfo: { company: '', address: '', taxCode: '', phone: '', email: '' },
    socialLinks: { facebook: '', youtube: '', tiktok: '', linkedin: '', twitter: '' },
    workingHours: {
      mondayFriday: '9:00 - 18:00 EST',
      saturday: '10:00 - 16:00 EST',
      sunday: 'Nghỉ',
      phoneHours: 'Thứ 2-6, 9:00-18:00 EST',
      emailResponse: 'Phản hồi trong 24 giờ',
    },
  },
  appearance: {
    themeMode: 'system',
    primaryColor: '#8b5cf6',
    // CMS (Admin) branding
    logo_asset_id: null,
    logo_url: '',
    favicon_asset_id: null,
    favicon_url: '',
    // Ecommerce storefront branding
    ecommerce_logo_asset_id: null,
    ecommerce_logo_url: '',
    ecommerce_favicon_asset_id: null,
    ecommerce_favicon_url: '',
    // Top Banner text for storefront
    topBannerText: 'Miễn phí vận chuyển cho đơn hàng trên 749.000₫+ | 4.990₫ vận chuyển cho đơn hàng trên 199.000₫+',
  },
  email: {
    smtpHost: '',
    smtpPort: 587,
    encryption: 'tls',
    fromEmail: '',
    fromName: 'PressUp CMS',
    username: '',
    password: '',
    enabled: false,
  },
  notifications: {
    newPost: true,
    newUser: true,
    newComment: true,
    systemUpdates: true,
  },
  security: {
    twoFactorEnabled: false,
    sessionTimeout: 60,
    passwordPolicy: { minLength: 8, uppercase: true, numbers: true, special: false },
  },
  advanced: {
    apiBaseUrl: process.env.API_BASE_URL || process.env.BASE_URL || 'http://localhost:3011',
    cacheStrategy: 'memory',
  },
  seo: {
    pages: [],
  },
  homepage_metrics: {
    activeCustomers: '84000+',
    countriesServed: '47',
    yearsInBusiness: '40+',
  },
};

export const getNamespace = async (req: Request, res: Response) => {
  try {
    const { namespace } = req.params;
    
    // Special handling for SEO namespace - read from page_metadata table
    if (namespace === 'seo') {
      try {
        const PageMetadata = (await import('../models/PageMetadata')).default;
        
        const pages = await PageMetadata.findAll({
          order: [['path', 'ASC']],
        });

        // Transform to match old settings format for backward compatibility
        const transformed = {
          home: DEFAULTS.seo.home,
          pages: pages.map((page) => ({
            path: page.path,
            title: page.title || '',
            description: page.description || '',
            ogImage: page.og_image || '',
            keywords: page.keywords || [],
            enabled: page.enabled !== undefined ? page.enabled : true,
            autoGenerated: page.auto_generated !== undefined ? page.auto_generated : false,
          })),
        };
        
        return res.json({ namespace: 'seo', value: transformed });
      } catch (error: any) {
        console.error('[getNamespace] Error reading from page_metadata:', error);
        // Fallback to old settings table
      }
    }
    
    // For other namespaces, use old settings table
    const row = await sequelize.query('SELECT value FROM settings WHERE namespace = :ns', {
      type: 'SELECT' as any,
      replacements: { ns: namespace },
    });
    const val = (row as any[])[0]?.value ?? DEFAULTS[namespace] ?? {};
    res.json({ namespace, value: val });
  } catch (err) {
    res.status(500).json({ error: 'Failed to load settings' });
  }
};

export const putNamespace = async (req: AuthRequest, res: Response) => {
  try {
    // Require auth but allow any logged-in user to save for now; could restrict by role
    if (!req.user) return res.status(401).json({ error: 'Unauthorized' });
    const { namespace } = req.params;
    const value = req.body;
    
    // Log for SEO namespace to debug
    if (namespace === 'seo') {
      console.log('[putNamespace] Saving SEO settings:', JSON.stringify(value, null, 2));
      if (value.pages && Array.isArray(value.pages)) {
        console.log('[putNamespace] Pages count:', value.pages.length);
        value.pages.forEach((p: any, i: number) => {
          console.log(`[putNamespace] Page ${i}:`, { path: p.path, title: p.title?.substring(0, 30), enabled: p.enabled });
        });
        
        // Sync to page_metadata table
        try {
          const { syncSeoSettingsToPageMetadata } = await import('../utils/syncSeoSettingsToPageMetadata');
          await syncSeoSettingsToPageMetadata(value.pages);
          console.log('[putNamespace] Synced SEO pages to page_metadata table');
        } catch (syncError) {
          console.error('[putNamespace] Failed to sync to page_metadata table:', syncError);
          // Don't fail the save if sync fails
        }
      }
    }
    
    const jsonValue = JSON.stringify(value);
    console.log('[putNamespace] JSON value to save (first 500 chars):', jsonValue.substring(0, 500));
    console.log('[putNamespace] Full JSON length:', jsonValue.length);
    
    try {
      // Use raw query without RETURNING, then verify separately
      await sequelize.query(
        `INSERT INTO settings (namespace, value, updated_at)
         VALUES (:ns, :val::jsonb, NOW())
         ON CONFLICT (namespace) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()`,
        { type: 'INSERT' as any, replacements: { ns: namespace, val: jsonValue } }
      );
      
      console.log('[putNamespace] Insert/Update completed');
      
      // Verify the save by reading back
      const verifyResult = await sequelize.query(
        'SELECT value FROM settings WHERE namespace = :ns',
        {
          type: 'SELECT' as any,
          replacements: { ns: namespace },
        }
      ) as any[];
      
      console.log('[putNamespace] Verify result type:', Array.isArray(verifyResult) ? 'array' : typeof verifyResult);
      console.log('[putNamespace] Verify result length:', Array.isArray(verifyResult) ? verifyResult.length : 'N/A');
      
      if (Array.isArray(verifyResult) && verifyResult.length > 0) {
        console.log('[putNamespace] Verify result[0]:', JSON.stringify(verifyResult[0], null, 2));
        const savedValue = verifyResult[0]?.value;
        console.log('[putNamespace] Saved value extracted:', savedValue ? 'exists' : 'null/undefined');
        console.log('[putNamespace] Saved value type:', typeof savedValue);
        
        if (savedValue) {
          console.log('[putNamespace] Verified saved value:', JSON.stringify(savedValue, null, 2));
          
          if (namespace === 'seo') {
            if (savedValue?.pages) {
              console.log('[putNamespace] Verified pages count:', savedValue.pages.length);
              savedValue.pages.forEach((p: any, i: number) => {
                console.log(`[putNamespace] Verified page ${i}:`, { path: p.path, title: p.title?.substring(0, 30) });
              });
            } else {
              console.error('[putNamespace] ERROR: Saved value has no pages!', savedValue);
            }
          }
        } else {
          console.error('[putNamespace] ERROR: Could not extract value from verify result!', verifyResult);
        }
      } else {
        console.error('[putNamespace] ERROR: Verify result is empty or invalid!', verifyResult);
      }
    } catch (dbError: any) {
      console.error('[putNamespace] Database error:', dbError);
      console.error('[putNamespace] Database error message:', dbError.message);
      console.error('[putNamespace] Database error stack:', dbError.stack);
      throw dbError; // Re-throw to be caught by outer catch
    }
    
    // Log activity (don't let this fail the save)
    try {
      await logActivity(req, 'update', 'settings', namespace, namespace, `Updated settings: ${namespace}`);
    } catch (activityError) {
      console.warn('[putNamespace] Failed to create activity log (non-critical):', activityError);
    }
    
    res.json({ ok: true });
  } catch (err) {
    console.error('[putNamespace] Error:', err);
    if (err instanceof Error) {
      console.error('[putNamespace] Error message:', err.message);
      console.error('[putNamespace] Error stack:', err.stack);
    }
    res.status(500).json({ error: 'Failed to save settings' });
  }
};

export const clearCache = async (_req: AuthRequest, res: Response) => {
  // TODO: Hook into real cache layer (redis/memory). For now, stub success.
  res.json({ ok: true, message: 'Cache cleared' });
};

export const resetDefaults = async (req: AuthRequest, res: Response) => {
  try {
    const scope = req.body?.scope || 'appearance';
    const defaults = DEFAULTS[scope] ?? {};
    await sequelize.query(
      `INSERT INTO settings (namespace, value, updated_at)
       VALUES (:ns, :val::jsonb, NOW())
       ON CONFLICT (namespace) DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()`,
      { type: 'INSERT' as any, replacements: { ns: scope, val: JSON.stringify(defaults) } }
    );
    res.json({ ok: true, defaults });
  } catch (err) {
    res.status(500).json({ error: 'Failed to reset defaults' });
  }
};
